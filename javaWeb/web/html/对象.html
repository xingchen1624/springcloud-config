<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象</title>
    <script type="text/javascript">
        /**
         * ES是国际标准化组织发布的浏览器脚本语言的标准，全名：ECMAScript。
         ES是JS语言的国际标准，JS是ES的实现。在日常场合，两个词可以互换。
         ES是JS的子集，它是JS的内容的一部分，一个完整的JS实现是由以下三部分组成：
         核心（ESMAScript）：规定了JS的语法、类型、语句、关键字、保留字、操作符、对象
         文档对象模型（DOM）：是用于HTML的应用接口（API），将整个页面映射为一个多层节点结构。
         浏览器对象模型（BOM）：与DOM不同，无标准，只是JS一部分，用来对浏览器进行访问和操作

         * String,Number,Boolean,Null,Undefined --五种基本数据类型
         * Object -- 引用类型
         * 对象属于复合数据类型，可以保存多个不同数据类型的数据
         * 对象分类：
         * ①内建对象：由ES标准定义的对象，在任何的ES中都可以使用
         * eg:Math,String,Number,Object,Function,Boolean等等
         * ②宿主对象
         * 由JS的运行环境提供的对象，目前主要是指浏览器提供的对象
         * eg:BOM  DOM
         * ③自定义对象
         * 开发人员自定义的对象
         */

        /**
         * 使用new 关键字调用的函数是构造函数，构造函数是专门用来创建对象的函数
         * @type {Object}
         */
        var obj = new Object();
        // console.log(obj);

        /**
         * 向对象中添加属性
         * 语法:对象.属性名 = 属性值
         */
        obj.name = 'poly crime';
        obj.age = 15;
        obj.test = 'test property';
        console.log(obj);

        /**
         * 读取属性
         * 语法：对象.属性名
         */
        console.log(obj.name);

        /**
         * 修改属性值
         * 语法：对象.属性名 = 新属性值
         */
        obj.name = '孙悟空';
        console.log(obj.name);

        /**
         * 删除对象属性
         * 语法：delete 对象.属性名
         */
        delete obj.test;
        console.log(obj.test);

        /**
         * 对象的属性名不强制要求遵守标识符规范，关键字都可以使用，但不建议使用
         * 使用特殊的属性名时，不能使用 . 的方式，需要用另一种方式
         * 语法 对象["属性名"] = 属性值
         *
         * 使用[]操作对象的属性，更加灵活，
         * 在[]中可以添加一个变量，变量的值是多少就会去读取哪个属性
         */
        obj.var = 11;
        obj.你好 = 45;
        obj["1"] = 2;
        var x = 'name';
        console.log(obj.var);
        console.log(obj.你好);
        console.log(obj["1"]);
        console.log(obj[x]);

        /**
         * 对象的属性值可以是任意的数据类型，也可以是一个函数
         */
        obj.val = 'a';
        obj.val = 1;
        obj.val = true;
        obj.val = null;
        obj.val = undefined;
        obj.val = NaN;
        /**
         * 函数作为对象的一个属性，那么这个函数被称为对象的方法
         * */
        obj.say = function(){
            alert('函数作为对象的属性值');
        };
        obj.say();
        console.log(obj.val);

        /**
         * in运算符
         *  - 通过该运算符可以判断一个对象中是否包含某个属性，有返回true，否则false
         *  语法："属性名" in 对象
         */
        console.log('name' in obj);

        /**
         * 枚举对象中的属性
         * 使用for in
         * 语法：
         *      for(var 变量 in 对象){
         *
         *      }
         */
        var obj5 = {
          name:'史蒂夫',
          age:45,
          tel:'134524513'
        };

        for (var obj5Key in obj5) {
            console.log('属性名:'+obj5Key);
            console.log('属性值:'+obj5[obj5Key]);
        }

        /**
         * 1.直接创建一个对象
         * @type {{name: string, age: number, sayName: p1.sayName}}
         */
        var p1 = {
            name:'张三',
            age:20,
            sayName:function () {
                console.log(this.name);
            }
        };

        /**
         * 2.使用工厂方法创建对象
         * 通过工厂方式大批量创建对象
         * 使用工厂方法创建对象，使用的构造函数其实都是Object的构造函数
         * 所以创建的对象都是Object类型的，无法区分具体的对象类型,从而引申出构造函数方式
         */
        function createByFactory(name,age){
            //创建一个对象
            var obj = new Object();
            //向对象中添加属性
            obj.name = name;
            obj.age = age;
            obj.sayName = function () {
                console.log(this.name);
            };

            //返回对象
            return obj;
        }

        var p2 = createByFactory('王五',39);
        var p3 = createByFactory('赵柳',19);

        p2.sayName();
        p3.sayName();

        /**
         * 3.构造函数的方式创建对象，可以区分对象的类型
         * 构造函数就是一个普通的函数，不同的是构造函数习惯上首字母大写，不是强制要求
         * 构造函数调用方式不同，普通函数是直接调用，而构造函数需要使用new关键字来调用
         *
         * 构造函数的执行流程：
         *  ①立即新建一个对象
         *  ②将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
         *  ③执行构造函数中的代码
         *  ④将新建的对象返回
         *
         *  构造函数可以称为一个类，使用构造函数创建的对象称为类的一个实例
         */
        function Person(name,age) {
            this.name = name;
            this.age = age;
            this.sayName = function () {
                alert('my name is '+this.name);
            }
        }

        //像普通函数一样调用
        var per1 = Person();
        console.log('person1:'+per1);

        //构造函数的方式调用
        var per2 = new Person('憨批',20);
        var per3 = new Person('老外',201);
        console.log('person2:'+per2.name);
        console.log('person3:'+per3.sayName());

        //使用instanceof检查一个对象是否是一个类的实例
        console.log(per2 instanceof Person);

        /**
         * 构造函数优化
         * 上面的构造函数方式创建对象，有一个问题构造函数中的sayName方法，而这个方法是一样的
         * 当我们每次执行构造函数的时候都会重新创建一次这个方法，考虑让所有对象使用同一个方法
         */

        function Person2(name,age) {
            this.name = name;
            this.age = age;
            this.sayName = sayName2;
        }

        function sayName2(){
            console.log('my name is '+this.name);
        }

        var per5 = new Person2('haha',323);
        console.log(per5.name);

        /**
         * 将方法从构造函数中提出来,在全局作用域中构建
         * 但是这样还有一个问题，将函数定义在全局作用域，污染了全局作用域的命名空间
         * 明明只是给Person构造函数用的方法，却在全局作用域里，而且定义在全局作用域
         * 有被覆盖的危险，如果是协同多人开发，也不安全。解决方案 使用原型
         */
        function Person3(name,age) {
            this.name = name;
            this.age = age;
        }

        //向原型中添加方法
        Person3.prototype.sayName3 = function () {
            alert("my name is"+this.name);
        }

        var person10 = new Person3('安抚',23);
        person10.sayName3();


    </script>
</head>
<body>

</body>
</html>